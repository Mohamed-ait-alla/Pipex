fork() => split the main process into two processes or two lines of executions
		  and returns an id and the child process has always 0. and the child process has
		  exactly the same memory as the main process.
wait() => this function interrupt the main process until the child process complete its 
		  execution. and it waits only for one child process to complete its execution for 
		  example if we have a parent process has two children the first one complete its exe..
		  will terminate the wait and then the parent will terminate its exe.. and we can fix that
		  using a while loop (while (wait(NULL) != -1 || errno != ECHILD)).

pipe() => this function creates or opens two files in memory. the fd[0] is for reading and fd[1] is
		  is for writing and it returns 0 in sucess and -1 it is not.

mkfifo() => its actually named pipe or it does the same job as pipe but it can create just one files
		    and when you try to open that file or reading it the open or write function will block untill
			another process reading or writing to that file.

		#___________exec family function___________#
_execl() => this function executes another program but it will create another process on the top of the main 
			process so it will overwrite the main process and it will execute just what is in its pramaters.
			so we usually call these exec functions in child processes;
_execlp() => this function is the same as _execl(). just this one uses the path variable to look at the path of
			 the executable of a command to execute. so instead ot passing it a the whole path we pass just the
			 name of the command and it will search for this executable file in the system

		#____________duplicate fd functions_________#

dup() => this function takes as a parameter an fd, and it duplicate or clone the current fd and returns a new fd.
dup2() => this function is similar to dup() but it takes another parameter called fd2 and its value that dup2() will
		  assign to the duplicated file , and when an fd is already exist it close it and relplace it with the duplicated
		  even if it 1 or 0 or 2 

		#____________built-in vs external commands____________#

built-in commands: are commands that build in the shell itself and doesn't require a path envirement to found it,
					and also doesn't require a new process to execute them. they get executed in main the process itself.
				 	and they are faster than external because external needs a new process.

external commands: are commands that are stored as separate executable files (binaries or scripts) and located in PATH envirement
					variable and require the shell to create new process using fork().

=> you can check if the command is built-in or not using type command.

		#____________copy-on-write (COW)_____________#

COW  : is a resource management technique in memory managements between processes especially parents with childs. the main idea of COW
		is that when a parent 1 creates a child 2 they have the same exactly memory space, but when the parent 1 wants to modify a page memory
		then the COW concept will come and will just have the copy of the page that he wants to modify, and this way it does't affect the the child 
		process.

		#__________Process control block (PCB)__________#

(PCB): used to track the process's execution satatus. each block of memory contains infos about the process state, program conter, stack pointer, satatus
		of opened files ..., and all this infos is required and must be saved when the prcess is switched from one state to another, and is a data structure
		by the os to manage infos about a process.

(IPC): Inter process communication (IPC) allows different programs or processes running on a computer to share information with each other. IPC allows
		 processes to communicate by using different techniques like sharing memory, sending messages, or using files. and the two fundamental models of IPC are:
		  -- shared memory : it requires processes to share some variables
		  -- message passing
		  -- semaphores and etc..

context-switching: involes saving the context or state of a running process so that it can be restored later, and then loading the context or state of another process
					and run it. when a context switch occurs, the kernel saves the state of the old process in its (PCB) and loads the saved context of the new process
					scheduled to run.